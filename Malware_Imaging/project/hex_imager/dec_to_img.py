# Standard Library Imports
import io
import os
import sys

# Conda Imports
import numpy as np
import cv2 as cv

# Project Defined Imports
from Malware_Imaging.config import DATA_DIRECTORIES, IMAGE_DIRECTORIES, COLORED_DIRECTORIES, get_image_width


def dec_to_img():

    # Declaring Imgae Widths, and FILE SIZE for Each File
    FILE_SIZE = [
        os.path.getsize(file) * 0.001 for file in DATA_DIRECTORIES["DEC_FILES"]
    ]
    TOTAL_SIZE = sum(FILE_SIZE)
    IMAGE_WIDTH = [get_image_width(size) for size in FILE_SIZE]

    # Initializing completed to display how far along the process is going
    # And printing to the user to let them know it has begun.
    completed = 0
    print("Converting Decimal Files to Images")

    # The loop has zip to make sure that all variables are in step
    # Size helps keep track of how far along, width help create the neccessary
    # array for the image sizing, File is the orignal hex dump,
    # and path is where the image will be saved.
    # A lot of these paths and values have been preprocessed in config
    for size, width, file, path in zip(
        FILE_SIZE,
        IMAGE_WIDTH,
        DATA_DIRECTORIES["DEC_FILES"],
        IMAGE_DIRECTORIES["MALWARE_DEC_IMAGES_PATHS"],
    ):
        # Vector is initialized to be empty as we read all values in,
        # This one dimensional vector is easier to convert into the
        # 2d numpy array
        vector = []
        with io.open(file, mode="r") as f:
            for line in f:
                vector.extend([digit for digit in line.split()])
            # The padding is to make sure that numpy can convert this
            # list into the propper 2d array
            # any list with the wrong width will make the array,
            # an array of lists. The value padding was chosen as [000]
            padding = width - (len(vector) % width)
            vector.extend(padding * ["000"])
            height = int(len(vector) / width)
            array_2D = np.array(vector, dtype=np.float32).reshape((height, width))
            cv.imwrite(path, array_2D)
            completed += size
            done = int(50 * completed / TOTAL_SIZE)

        # Print out updating the user how far along image creation is taking
        sys.stdout.write(
            "\r[{}{}] {}%".format(
                "█" * done, "." * (50 - done), int(100 * completed / TOTAL_SIZE)
            )
        )
        sys.stdout.flush()
    sys.stdout.write("\n")



def dec_to_colored_img():
    file_no = 1
    # Declaring Image Widths, and FILE SIZE for Each File
    FILE_SIZE = [
        os.path.getsize(file) * 0.001 for file in DATA_DIRECTORIES["DEC_FILES"]
    ]
    TOTAL_SIZE = sum(FILE_SIZE)
    IMAGE_WIDTH = [get_image_width(size) for size in FILE_SIZE]

    # Initializing completed to display how far along the process is going
    # And printing to the user to let them know it has begun.
    completed = 0
    print("Converting Decimal Files to Nonoverlap Colored Images")

    # The loop has zip to make sure that all variables are in step
    # Size helps keep track of how far along, width help create the neccessary
    # array for the image sizing, File is the orignal hex dump,
    # and path is where the image will be saved.
    # A lot of these paths and values have been preprocessed in config
    for size, width, file, nonoverlap_path, overlap_path in zip(
        FILE_SIZE,
        IMAGE_WIDTH,
        DATA_DIRECTORIES["DEC_FILES"],
        COLORED_DIRECTORIES["NONOVERLAP_COLORED_IMAGE_PATHS"],
        COLORED_DIRECTORIES["OVERLAP_COLORED_IMAGE_PATHS"],
    ):
        # Vector is initialized to be empty as we read all values in,
        # This one dimensional vector is easier to convert into the
        # 3d numpy array
        print("[{}/6200] Generating colored images for file {}".format(file_no, file))
        nonoverlap_vector = []
        overlap_vector = []
        with io.open(file, mode="r") as f:    
            for line in f:
                current_line = line.split()
                for i in range(len(current_line)-1):
                    # create nonoverlapping vector
                    nonoverlap_vector.append(current_line[i])
                    # create vector of bigrams
                    overlap_vector.extend([current_line[i], current_line[i+1]])
                # add last digit in line to nonoverlapping vec since loop ends one digit before the EOL
                nonoverlap_vector.append(current_line[len(current_line)-1])

            # Original implementation of vector creation
            '''
                nonoverlap_vector.extend([digit for digit in current_line])

                # Get bigrams from current line and flatten
                # Example: bigrams = [(d,arr[i+1]) for i,d in enumerate(arr) if i < len(arr)-1]
                overlap_vector.extend([[digit,current_line[i+1]] for i, digit in enumerate(current_line) if i < len(current_line)-1])
            
            # flatten overlap vector from bigrams to one dimensional vector
            overlap_vector = [digit for sublist in overlap_vector for digit in sublist]
            '''    

            # The padding is to make sure that numpy can convert this
            # list into the proper 3d array
            # any list with the wrong width will make the array,
            # an array of lists. The value padding was chosen as [000]

            # This section for nonoverlap colored images
            padding = width * 3 - (len(nonoverlap_vector) % (width * 3))
            nonoverlap_vector.extend(padding * ["000"])
            height = int(len(nonoverlap_vector) / (width*3))
            array_3D = np.array(nonoverlap_vector, dtype=np.float32).reshape(height,width,3)
            cv.imwrite(nonoverlap_path, array_3D)


            # This section for overlap colored images
            padding = width * 3 - (len(overlap_vector) % (width * 3))
            overlap_vector.extend(padding * ["000"])
            height = int(len(overlap_vector) / (width*3))
            array_3D = np.array(overlap_vector, dtype=np.float32).reshape(height,width,3)
            cv.imwrite(overlap_path, array_3D)
        
        print("[{}/6200] Finished generating colored images".format(file_no))
        file_no += 1
    '''
            # completed += size
            # done = int(50 * completed / TOTAL_SIZE)
        
        # Print out updating the user how far along image creation is taking
        sys.stdout.write(
            "\r[{}{}] {}%".format(
                "█" * done, "." * (50 - done), int(100 * completed / TOTAL_SIZE)
            )
        )
        sys.stdout.flush()
    sys.stdout.write("\n")
    '''
